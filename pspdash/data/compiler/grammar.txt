
Package pspdash.data.compiler;

Helpers

    all = [0 .. 0xffff];
    not_crlf = [all - [10 + 13]];
    digit = ['0' .. '9'];
    nondigit = ['_' + [['a' .. 'z'] + ['A' .. 'Z']]];
    digit_sequence = digit+;
    not_star = [all - '*'];
    not_star_slash = [not_star - '/'];

    sign = '+' | '-';
    float = '-'? digit_sequence? '.' digit_sequence;
    integer = '-'? digit_sequence '.'?;
    unusual_num = 'NaN' | '-'? 'Infinity';

    cr = 13;
    lf = 10;
    tab = 9;

    escape_sequence = '\' ''' | '\"' | '\\' | '\n' | '\t' | '\[' | '\]';

    i_char = [not_crlf - [['[' + ']'] + '\']] | escape_sequence; //'
    i_char_sequence = i_char+;

    s_char = [not_crlf - ['"' + '\']] | escape_sequence; //'
    s_char_sequence = s_char+;

    old_style_continue_char = [not_crlf - ['=' + 9]];
    old_style_inital_char = [old_style_continue_char -  ['[' + ' ']];
    old_style_identifier = old_style_inital_char old_style_continue_char*;
    old_style_equals = '=' | '==';

    a = ['a' + 'A'];
    n = ['n' + 'N'];
    d = ['d' + 'D'];
    o = ['o' + 'O'];
    r = ['r' + 'R'];
    t = ['t' + 'T'];
    s = ['s' + 'S'];
    e = ['e' + 'E'];
    c = ['c' + 'C'];
    h = ['h' + 'H'];

    and = a n d;
    or = o r;
    not = n o t;
    search = s e a r c h;

States
   b, // beginning of line
   i; // inline

Tokens

    {b, i->b} eol = cr | lf | cr lf;

    {b->i, i} comma = ',';
    {b->i, i} l_par = '(';
    {b->i, i} r_par = ')';
    {b->i, i} mult = '*';
    {b->i, i} div = '/';
    {b->i, i} plus = '+';
    {b->i, i} minus = '-';
    {b->i, i} concat = '&';
    {b->i, i} pathconcat = '&/';
    {b->i, i} logic_not = '!' | not;
    {i}       eq = '==';
    {i}       equal = '=';

    {b->i, i} neq = '!=' | '<>';
    {b->i, i} lt = '<';
    {b->i, i} lteq = '<=';
    {b->i, i} gt = '>';
    {b->i, i} gteq = '>=';
    {b->i, i} logic_and = '&&' | and;
    {b->i, i} logic_or = '||' | or;
    {b->i, i} semicolon = ';';

    {b->i, i} identifier = '[' i_char_sequence ']';
    {b->i, i} string_literal = '?'? '"' s_char_sequence? '"';
    {b->i, i} zero_literal = '0' | '0.0';
    {b->i, i} number_literal = '?'? (float | integer | unusual_num);
    {b->i, i} date_literal = '?'? '@' digit_sequence;
    {b->i, i} null = 'null';
    {b->i, i} tag = 'TAG';
    {b->i, i} search = search;
    {b->i, i} function_name = nondigit+;

    {b->i, i} blank = (tab | ' ')+;
    {b->i, i} slash_slash_comment = '//' not_crlf*;
    {b->i, i} slash_star_comment =
        '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';
    {b->i} initial_equals_comment = '=' not_crlf*;

    {b->i} old_style_declaration =
        old_style_identifier old_style_equals not_crlf+;
    {b->i} include_directive = '#include <' not_crlf+ '>';


Ignored Tokens
    
    blank, eol,
    slash_star_comment, slash_slash_comment, initial_equals_comment;


Productions

  datafile = declaration+;

  declaration =
    {new_style} identifier assignop value semicolon |
    {old_style} old_style_declaration |
    {search} identifier assignop search l_par
         [start]:string_literal [c1]:comma [tag]:string_literal [c2]:comma
         [expression]:value r_par semicolon |
    {include} include_directive;

  assignop =
    {normal} equal |
    {read_only} eq;

  value =
    {date} date_literal |
    {null} null |
    {tag} tag |
    {expression} expression;

  expression =
    {numeric} level7_expr;

  level7_expr =
    {null} level6_expr |
    {binary} [left]:level7_expr [op]:logic_or [right]:level6_expr;

  level6_expr =
    {null} level5_expr |
    {binary} [left]:level6_expr [op]:logic_and [right]:level5_expr;

  level5_expr =
    {null} level4_expr |
    {binary} [left]:level4_expr [op]:relop [right]:level4_expr;

  relop =
    {eq}   eq |
    {neq}  neq |
    {lt}   lt |
    {lteq} lteq |
    {gt}   gt |
    {gteq} gteq;

  level4_expr =
    {null} level3_expr |
    {string} string_literal |
    {binary1} [left]:level4_expr [op]:stringop [right]:level3_expr |
    {binary2} [left]:level4_expr [op]:stringop [right]:string_literal;

  stringop =
    {concat} concat |
    {pathconcat} pathconcat;

  level3_expr =
    {null} level2_expr |
    {binary} [left]:level3_expr [op]:addop [right]:level2_expr;

  addop =
    {plus} plus |
    {minus} minus;

  level2_expr =
    {null} level1_expr |
    {binary} [left]:level2_expr [op]:multop [right]:level1_expr;

  multop =
    {mult} mult |
    {div} div;

  level1_expr =
    {null} term |
    {unary_not} [op]:logic_not [right]:term |
    {unary_minus} [op]:minus [right]:term;

  term =
    {zero} zero_literal |
    {number} number_literal |
    {identifier} identifier |
    {call} function_call |
    {expr} l_par expression r_par;


  function_call =
    function_name l_par arglist? r_par;

  arglist =
    value arglist_tail*;

  arglist_tail =
    comma value;
