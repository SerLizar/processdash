<html>
<head>
<title>Defining a Custom LOC Counter</title>
<link rel=stylesheet type="text/css" href="../../style.css">
</head>
<body>

<h1>Defining a Custom LOC Counter</h1>

<p>In the PSP, lines of code (LOC) are often used to measure the size of a
software component.  To produce a size measurement that is useful for
planning and analysis purposes, PSP recommends that you separately account
for base, added, modified, and deleted LOC.  In addition, it recommends
that you exclude comment lines, blank lines, and automatically-generated
code from the count.</p>

<p>Although many free and commercial LOC counters are available, they
typically only measure total LOC, and they often include comment lines in
the counts they produce.  For this reason, the dashboard provides a simple
<a href="../PostmortemAnalysis/LOCCounter.html">LOC counting tool</a> that
developers can use to measure base, added, modified, and deleted LOC in a
PSP-recommended way.</p>

<p>To properly exclude comments from the count, this LOC counting tool must
have a rudimentary understanding of the programming language syntax.
Accordingly, the LOC counting tool is prepopulated with several language
filters that recognize the syntax of many popular programming languages.
The LOC counter can automatically handle files of the following types:</p>

<ul>

<li>C-style languages like C, C++, C#, and Java <i>(where single-line
comments begin with </i><tt>//</tt><i>, and block comments are bounded by
</i><tt>/*&nbsp;*/</tt><i>)</i></li>

<li>Shell-style languages <i>(where single-line comments begin with the
</i><tt>#</tt><i> character)</i></li>

<li>Pascal and other similar languages <i>(where single-line comments begin
with </i><tt>//</tt><i>, and block comments are bounded by
</i><tt>{&nbsp;}</tt><i>)</i></li>

<li>SQL and other similar languages <i>(where single-line comments begin
with </i><tt>--</tt><i>, and block comments are bounded by
</i><tt>/*&nbsp;*/</tt><i>)</i></li>

<li>Cobol <i>(which includes line numbers and uses a character in a
specific column to flag a line as a comment)</i></li>

<li>A plain-text filter, which recognizes no comment syntax and counts all
nonblank lines. <i>(This filter is used by default if none of the other
filters appear appropriate.)</i></li>

</ul>

<p>Of course, many other source code languages exist, and you may find
yourself needing to count LOC for a language not handled above.
Fortunately, the dashboard allows language filters to be defined and loaded
dynamically, so you can create your own custom language filters for use
with the dashboard's LOC counter.</p>

<p>To create a custom language filter, follow these steps:</p>

<ol>
 <li><a href="#CountingStandard">Decide what lines of code should be
counted</a></li>

 <li><a href="#XmlDef">Create an XML definition for your language filter</a></li>
 <LI><A HREF="#XmlDesc">Save your XML language filter definition</A></LI>
 <LI><A HREF="#Restart">Restart the dashboard</A></LI>
</OL>



<h2><a name="CountingStandard">Step 1: Decide what lines of code should be counted</a></h2>

<p>In the PSP, we seek to identify size measures that correlate well to
development effort.  While LOC is not perfect, we nevertheless want to
craft our LOC counting standard so it supports this goal.</p>

<p>The PSP makes several recommendations to help us get started.  For
example, it recommends that we do not count comments, blank lines, or
autogenerated code.</p>

<p>Following this advice, the dashboard's LOC counter automatically ignores
lines that contain only whitespace.  In Step 2(c) below, you will tell the
LOC counter about the comment syntax for your programming language, so it
can exclude comments from the count as well.</p>

<p>Autogenerated code can be trickier.  But occasionally you may find that
a particular type of autogenerated code follows a simple pattern, and can
be excluded.  For example, it is common for Java IDEs to automatically
manage the <tt>import</tt> statements at the top of the file; if you
regularly use that IDE feature, you might choose to exclude <tt>import</tt>
statements from the LOC count.</p>

<p>In addition, be wary that autogenerated code may be present in your
source code but invisible to you!  Some IDEs (for example, Visual Studio)
have been known to attach large headers or footers to a source file, but
not display those headers/footers when the file is opened in the IDE.  Use
a plain text editor like Notepad or Emacs to open several typical source
files and see if the contents match your expectations.</p>

<p>Finally, the PSP makes a blanket recommendation: if you aren't certain
whether a particular line should be counted, try running your metrics both
ways, then see which approach gives you a better correlation between size
and effort.</p>

<p>As an example, this technique was used by the dashboard development team
to determine that curly braces appearing on their own line usually
<b>should not</b> be included in LOC counts of C-style languages.  When you
think about this, it becomes clear why.  Consider the following three code
fragments:</p>

<table border="1"><tr>
<td valign="top"><pre>  if (test)
    then-clause;  
  else
    else-clause;  </pre></td>

<td valign="top"><pre>  if (test) {  
    then-clause;  
  } else {  
    else-clause;  
  }</pre></td>

<td valign="top"><pre>  if (test)
  {
    then-clause;  
  }
  else
  {
    else-clause;  
  }</pre></td>

</tr></table>

<p>For the purposes of this discussion, we aren't concerned about which of
these fragments is "superior."  We just want to think about how we should
count the LOC they contain.</p>

<p>As written, the three fragments are semantically equivalent, differing
only in the appearance and placement of the curly braces.  The bulk of the
programming effort will be invested in writing the test expression and the
two conditional clauses; thus, we would expect these three fragments of
code to require virtually identical effort to produce from scratch.  To
produce the best correlation between size and effort, we would ideally like
them to have the same size measurement.</p>

<p>If we were to count every nonblank line as a line of code, then the
third code fragment would allegedly be twice the size as the first
(allegedly requiring twice as much effort to produce).  That is
counterintuitive and can be rejected straightaway.  However, if we simply
ignore any curly brace that appears on a line by itself, we will receive
identical LOC counts from all three fragments.  In this way, ignoring lone
curly braces allows us to correct for varying whitespace styles across a
large code base, improving the quality of our size measurements.</p>

<p>Once you have decided which lines of code you wish to count, you're
ready for the next step.</p>


<h2><a name="XmlDef">Step 2: Create an XML definition for your language filter</a></h2>

<p>The dashboard supports a simple declarative XML syntax for the
definition of simple language filters. <B>The discussion below assumes that
you are familiar with XML.</B> If this is not the case, please go read a
nice tutorial on XML before proceeding!!</p>

<p>Here is an example of an XML description file for the C-style language
filter:</p>


<table border="1" width="100%">
 <tr>
  <td width="100%">
   <pre><font color="#0000FF">&lt;?xml version='1.0'?&gt;

&lt;dashboard-process-template&gt;</font>

   &lt;locFilter id=&quot;<font color="#008800"><b>C</b></font>&quot; fileSuffixes=&quot;<font color="#008800"><b>.c .cpp .c++ .h .java .cs</b></font>&quot;&gt;
      &lt;commentSyntax beginsWith=&quot;<font color="#008800"><b>//</b></font>&quot; /&gt;
      &lt;commentSyntax beginsWith=&quot;<font color="#008800"><b>/*</b></font>&quot; endsWith=&quot;<font color="#008800"><b>*/</b></font>&quot; /&gt;

      &lt;possibleFirstLine&gt;<font color="#008800"><b>#include</b></font>&lt;/possibleFirstLine&gt;
      &lt;possibleFirstLine&gt;<font color="#008800"><b>#define</b></font>&lt;/possibleFirstLine&gt;
      &lt;possibleFirstLine&gt;<font color="#008800"><b>#if</b></font>&lt;/possibleFirstLine&gt;
      &lt;possibleFirstLine&gt;<font color="#008800"><b>#pragma</b></font>&lt;/possibleFirstLine&gt;

      &lt;ignoreLine equalTo=&quot;<font color="#008800"><b>{</b></font>&quot; /&gt;
      &lt;ignoreLine equalTo=&quot;<font color="#008800"><b>}</b></font>&quot; /&gt;
   &lt;/locFilter&gt;

<font color="#0000FF">&lt;/dashboard-process-template&gt;</font></pre></td>
 </tr>
</table>

<p>The file begins and ends with the header and footer (which appear in
blue above). Between the header and footer, any number of LOC filters can
be defined through the use of the <tt>&lt;locFilter&gt;</tt> element
(please note that capitalization is significant).  Note that if you are
also creating <a href="ProcessDefinition/DefiningProcesses.html">custom
process definitions</a>, you can combine custom process
<tt>&lt;template&gt;</tt> definitions and custom <tt>&lt;locFilter&gt;</tt>
definitions in the same XML description file, mixing the tags in any
order.</p>

<h3 NO_NUMBER>Step 2(a): Assign a Unique ID</h3>

<p>Each LOC filter must have a unique identifier, which is specified in the
<tt>id</tt> attribute of the <tt>locFilter</tt> tag.  This identifier will
be displayed to end users in the LOC report, so it is best to choose a
human-readable string. If you reuse the same ID as a LOC filter built-in to
the dashboard (i.e., <tt>C, Sh, Pascal, SQL, Cobol, </tt>or<tt>&nbsp;Default</tt>),
your definition will replace the built-in filter.</p>

<h3 NO_NUMBER>Step 2(b): List Typical Filename Suffixes</h3>

<p>When you run a LOC comparison report, the dashboard looks at each file
being compared and attempts to determine which language filter is most
appropriate - a process called "LOC Filter Selection."  This process
involves several steps, but the first step is to look at the filename.  You
can use the <tt>fileSuffixes</tt> attribute to list the filename suffixes
(separated by spaces) that are commonly used for source code files in the
programming language you are describing.</p>

<h3 NO_NUMBER>Step 2(c): Define Comment Syntax</h3>

<p>For the purposes of LOC counting, comment syntax is the most important
difference between the various language filters.  You can declare any
number of comment styles for a language filter by creating embedded
<tt>&lt;commentSyntax&gt;</tt> elements.</p>

<p>Each <tt>&lt;commentSyntax&gt;</tt> element must have a
<tt>beginsWith</tt> attribute, indicating the string of characters that
begins a comment.  An <tt>endsWith</tt> attribute can also be specified,
indicating the sequence of characters that ends the comment.  If no
<tt>endsWith</tt> attribute is given, the "end-of-line" character will be
assumed; thus, single-line comment styles can be specified simply by a
<tt>beginsWith</tt> attribute.</p>

<p>If your programming language has blocks of auto-generated code that
begin with a distinctive sequence of characters, you may be able to use a
<tt>&lt;commentSyntax&gt;</tt> element to describe them.  Any matching
blocks will be excluded from LOC counts along with the other comments in
the file.</p>

<p>Technically, you could choose not to list any
<tt>&lt;commentSyntax&gt;</tt> elements.  The resulting LOC filter would
describe a language without comments, or alternatively, a language where
comments are included in LOC counts.  The "Default" filter is a
preinstalled example of this.</p>

<h3 NO_NUMBER>Step 2(d): List Possible First Lines (Optional)</h3>

<p>During the "LOC Filter Selection" process, if a file is encountered
whose filename doesn't match any recognized suffix, the dashboard will look
inside the file in an attempt to guess which language it contains.</p>

<p>Since it is very common for source code files to begin with a
descriptive comment, the dashboard will first check to see if the first
non-whitespace characters in the file appear to match any known comment
syntax (specified via a <tt>&lt;commentSyntax&gt;</tt> element as described
above).</p>

<p>If a particular file under comparison does not have a recognizable file
suffix and does not begin with a recognizable comment, the "LOC Filter
Selection" process might still be stumped.  In that case, you can
optionally list other strings that could legally appear at the beginning of
a source code file.  This is done by including embedded
<tt>&lt;possibleFirstLine&gt;</tt> elements.  If the first line of the file
begins with one of these strings, this LOC filter may be considered a
match.</p>

<p><tt>&lt;possibleFirstLine&gt;</tt> elements are completely optional;
most language filters will not need to use them.  In particular, remember
that these are only used as a last resort; normally files will be
categorized based on their filename suffix.</p>

<h3 NO_NUMBER>Step 2(e): List Ignored Lines (Optional)</h3>

<p>In addition to comments, there may be other lines of code that you wish
to exclude from LOC counts.  These can be specified by creating embedded
<tt>&lt;ignoreLine&gt;</tt> elements.  Each <tt>&lt;ignoreLine&gt;</tt>
element must have exactly one of the following attributes:</p>

  <ul>

  <li><tt>equalTo - </tt>lines of code should be ignored if they are equal
      to the given value. (Whitespace will be trimmed from the line of code
      before it is compared to the given value.)</li>

  <li><tt>beginningWith - </tt>lines of code should be ignored if they
     begin with the given value. (Whitespace will be trimmed from the line
     of code before it is compared to the given value.)</li>

  <li><tt>endingWith - </tt>lines of code should be ignored if they end
     with the given value. (Whitespace will be trimmed from the line of
     code before it is compared to the given value.)</li>

  <li><tt>containing - </tt>lines of code should be ignored if they contain
     the given value.</li>

  </ul>

<p>The lines of code in the file will be matched against these patterns; if
any pattern matches, the line will not be included in LOC counts. Keep in
mind that lines are tested one at at time; therefore, multiline patterns are
not supported.</p>


<h2><a name="XmlDesc">Step 3: Save your XML language filter definition</a></h2>

<p>Once your XML language filter definition is complete, it is time to save it 
somewhere 
<a href="ProcessDefinition/HowDashboardFindsFiles.html#FindFiles">where the
dashboard can find it</a>. Follow these steps:</p>

<ol>
 <li>Find your pspdash.jar file (on Windows machines, it is probably located 
   in <u>C:\Program Files\Process Dashboard</u>).</li>
 <li>Create a directory alongside it called "Templates" (e.g., <u>C:\Program 
   Files\Process Dashboard\Templates</u>).</li>
 <li>Save your XML language filter definition in that Templates directory. 
   <b>Important:</b> you must give your XML language filter definition a
   filename ending with "<code><b>-template.xml</b></code>" to signal to
   the dashboard that the file contains dashboard metadata.  If you do not
   choose a filename ending with "<code><b>-template.xml</b></code>", your
   language filter definition will be ignored.</li>
</ol>

<p>This is the simplest place to put your XML language filter
definition. Of course, if you want to share your LOC counting filter with
team members, you may want to put it somewhere else. See the section on 
<a href="ProcessDefinition/HowDashboardFindsFiles.html#FindFiles">how the
dashboard finds process files</a> for more information. Keep in mind that
the dashboard will search for "<code><b>-template.xml</b></code>" files in
the "Templates" directories only - subdirectories will not be searched.</p>

<h2><a name="Restart">Step 4: Restart the dashboard</a></h2>

<p>Once your XML language filter definition is in place, it is necessary to
shut down the dashboard and restart it for the new filter to be found.
Once found, it will automatically be included in the "LOC Filter Selection"
process when a LOC report is run.  If you make changes to your LOC filter
definition, a dashboard restart will also be required for your changes to
take effect.</p>


</body>
</html>
