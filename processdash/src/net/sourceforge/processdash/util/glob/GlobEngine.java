// Copyright (C) 2006-2013 Tuma Solutions, LLC
// Process Dashboard - Data Automation Tool for high-maturity processes
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 3
// of the License, or (at your option) any later version.
//
// Additional permissions also apply; see the README-license.txt
// file in the project root directory for more information.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, see <http://www.gnu.org/licenses/>.
//
// The author(s) may be contacted at:
//     processdash@tuma-solutions.com
//     processdash-devel@lists.sourceforge.net

package net.sourceforge.processdash.util.glob;

/*
 * Build note: this class uses many classes that are autogenerated during the
 * ant build process.  If your IDE or compiler is giving you error messages
 * about missing classes, you need to run ant!  See the file "README-build.txt"
 * in the root directory of this project for more information.
 */

import java.io.PushbackReader;
import java.io.StringReader;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

import net.sourceforge.processdash.data.ListData;
import net.sourceforge.processdash.data.SaveableData;
import net.sourceforge.processdash.data.SimpleData;
import net.sourceforge.processdash.data.StringData;
import net.sourceforge.processdash.util.glob.lexer.Lexer;
import net.sourceforge.processdash.util.glob.node.Start;
import net.sourceforge.processdash.util.glob.parser.Parser;

public class GlobEngine {

    /** Search through a list of tagged data for items that match a glob
     * expression.
     * 
     * @param expression the search expression
     *
     * @param taggedData
     * @param tagPrefix
     * @return
     */
    public static Set search(String expression, String tagPrefix,
            List taggedData) {
        return search(expression, tagPrefix, taggedData, null);
    }

    public static Set search(String expression, String tagPrefix,
            List taggedData, TaggedDataListSource deferredDataSource) {

        if (expression == null || expression.trim().length() == 0)
            return Collections.EMPTY_SET;

        return search(expression, extractTaggedValues(taggedData, tagPrefix),
            new TaggedMapExtractor(deferredDataSource, tagPrefix));
    }

    public static Set search(String expression, Map taggedData) {
        return search(expression, taggedData, null);
    }

    public static Set search(String expression, Map taggedData,
            TaggedDataMapSource deferredDataSource) {
        if (expression == null || expression.trim().length() == 0)
            return Collections.EMPTY_SET;

        Start s = compile(expression);
        if (s == null)
            return Collections.EMPTY_SET;

        GlobSearchEvaluator eval = new GlobSearchEvaluator(taggedData,
                deferredDataSource);
        eval.caseStart(s);

        Set matches = eval.getResult();
        if (matches == null || matches.isEmpty())
            return Collections.EMPTY_SET;
        else
            return matches;
    }

    /** @since 1.14.5 */
    public static Set<String> getTags(String tagPrefix, List taggedData) {
        return extractTaggedValues(taggedData, tagPrefix).keySet();
    }



    private static Map extractTaggedValues(List taggedData, String tagPrefix) {
        Map taggedValues = new HashMap();

        Set currentData = null;
        String currentTag = null;
        for (Iterator i = taggedData.iterator(); i.hasNext();) {
            Object value = i.next();
            String valueAsTag = isTag(value, tagPrefix);

            if (valueAsTag != null) {
                if (valueAsTag.length() > 0) {
                    currentTag = valueAsTag;
                    currentData = (Set) taggedValues.get(currentTag);
                } else {
                    currentTag = null;
                    currentData = null;
                }

            } else if (currentTag != null) {
                if (currentData == null) {
                    currentData = new HashSet();
                    taggedValues.put(currentTag, currentData);
                }
                currentData.add(value);
            }
        }
        return taggedValues;
    }

    private static String isTag(Object value, String tagPrefix) {
        if (value instanceof String) {
            String str = (String) value;
            if (str.startsWith(tagPrefix))
                return str.substring(tagPrefix.length()).toLowerCase();
        }

        return null;
    }

    public static boolean test(String expression, Object value) {
        if (expression == null || expression.trim().length() == 0
                || value == null)
            return false;

        Collection words = asCollection(value);
        if (words == null || words.isEmpty())
            return false;

        Start s = compile(expression);
        if (s == null)
            return false;

        GlobTestEvaluator eval = new GlobTestEvaluator(words);
        eval.caseStart(s);
        return eval.getResult();
    }

    private static Collection asCollection(Object value) {
        if (value instanceof Collection)
            return (Collection) value;
        else if (value instanceof SimpleData)
            return asCollection((SimpleData) value);
        else if (value instanceof SaveableData)
            return asCollection(((SaveableData) value).getSimpleValue());
        else
            return asCollection(String.valueOf(value));
    }

    private static Collection asCollection(SimpleData data) {
        if (!data.test())
            return null;
        if (data instanceof StringData)
            data = ((StringData) data).asList();
        if (data instanceof ListData) {
            Collection words = new HashSet();
            words.addAll(((ListData) data).asList());
            return words;
        } else
            return asCollection(data.format());
    }

    private static Collection asCollection(String text) {
        Collection words = new HashSet();
        String[] tokens = text.split("[,\u0000- ]+");
        words.addAll(Arrays.asList(tokens));
        return words;
    }


    private static final Map COMPILED_EXPRESSIONS = new Hashtable();

    private static final Logger logger = Logger
            .getLogger(GlobEngine.class.getName());


    private static Start compile(String expression) {
        Start result = (Start) COMPILED_EXPRESSIONS.get(expression);
        if (result == null) {
            try {
                Parser p = new Parser(new Lexer(new PushbackReader(
                        new StringReader(expression), 1024)));

                // Parse the input
                result = p.parse();
            } catch (Exception e) {
                logger.warning("Invalid glob expression: " + expression);
                e.printStackTrace();
            }
        }
        return result;
    }

    private static class TaggedMapExtractor implements TaggedDataMapSource {
        TaggedDataListSource data;
        String tagPrefix;

        protected TaggedMapExtractor(TaggedDataListSource data, String tagPrefix) {
            this.data = data;
            this.tagPrefix = tagPrefix;
        }

        public Map getTaggedData(String token) {
            List list = data.getTaggedData(token);
            return (list == null ? null : extractTaggedValues(list, tagPrefix));
        }
    }

}
